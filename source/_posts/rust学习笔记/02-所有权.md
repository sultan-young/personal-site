---
title: rust学习笔记 —— 所有权【重点】
date: 2022-09-23 15:08:48
categories: [rust]
tags: [rust]
---
> 所有权是Rust中最为与众不同的特性，他让Rust无需垃圾回收器(garbage collector)即可保证内存安全。因此，理解Rust中所有权的运作方式非常重要。

<!--more-->
## 什么是所有权？
所有运行的程序都必须管理器计算机的内存。一些预览具有垃圾回收机制，在程序运行过程中不断地寻找不再使用的内存(例如JavaScript)。另一些语言需要开发者亲自分配和释放内存（例如c，c++）。
Rust使用了第三种方式：通过所有权系统管理内存，编译期在编辑时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。

## 所有权规则
+ Rust中的每个值都有一个被称为其 **所有者** 的变量。
+ 值在任何一刻只能有一个所有者。
+ 当所有者（变量）离开作用域，这个值将会丢弃。


## 内存分配
就字符串字面量来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使字符串字面量快速且高效。不过这些特性都得益于字符串字面量的不可变性。但我们不能将在编译时候大小未知的文本放置到二进制文件中。

为了支持一个可变的、可增长的文本片段。需要在对上分配一块在编译时未知大小的内存来存放内容，这一位置：
+ 必须在运行时向内存分配器请求内存。
+ 需要一个当我们处理完之后，将内存返回分配器的方法。

```rust
    fn main() {
        {
            let s = String::from("hello"); // 从此处起，s 开始有效

            // 使用 s
        }                                  // 此作用域已结束，
                                        // s 不再有效
    }
```
> String:from 创建一个可变的字符串，它会存储到内存的堆中。

以上代码，当s变量离开作用域时候，Rust会自动帮我们调用一个 `drop` 的函数。

## 变量与数据交互（-）：移动
在Rust中，多个变量能够以不同的方式与同一数据交互。
```rust
fn main() {
    let x = 5;
    let y = x;
     println!("{}, {}", x, y); // 程序会正常执行
}
```
这里将5绑定到了x变量上，接着有奖x的值**拷贝**到了y。现在有了两个变量 x 和 y，他们都等于五。因为整数是固定大小的简单值，所以这两个5被放入了栈中。
再来看一下String：
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}, world!", s1); // 程序会报错
}
```
这里和之前的行为完全不一致, 由于s1是存放在堆中的变量，所以在将s1赋值给s2的时候，发生了指针移动。移动过后，s1只拷贝了s1的指针，而不会拷贝s1中在堆内存中存放的具体值。在发生指针之后，rust还会进行一个额外的操作，就是将s1无效化。所以这里打印s1程序会报错。

## 变量和数据交互（二）克隆
如果我们确实需要深度赋值String中堆的数据，可以使用一个叫 `clone` 的通用函数。
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
}
```
这段代码可以正常运行，因为堆上的数据被复制了，s1保持了原有的引用，是有效的。
> 当出现`clone` 调用时候，可能会相当消耗资源。

像整型这种，被存储在栈上的。在进行 `let s2 = s1` 的时候会直接进行拷贝。因为拷贝值是快速的。这意味着没有理由在创建了s2 后令s1无效。

> Rust 有一个叫做 `copy trait` 的特殊标注，可以用在类似整型这样的存储在栈上的类型。如果一个类型实现了 `copy trait` ，那么久的变量在其赋值给其他变量后依然可用。Rust不允许自身或其任何部分实现了 `Drop trait` 的类型使用 `Copy trait`。

以下类型实现了 `copy trait`：
+ 所有整数类型，例如 `u32`。
+ 布尔类型，`bool` 
+ 所有浮点数类型。
+ 字符类型， `char`
+ 元祖，当且仅当其包含的类型也都实现了 `Copy` 的时候，比如 `(i32, i32)` 就实现了 `copy`。但是 `(i32, Sting)` 就没有。

## 栈（Stack）与 堆 (Heap)
在很多语言中，你并不需要关注到堆和栈。但在像Rust这样的系统编程语言中，值是位于栈上还是堆上很大程度上影响了语言的行为（表示很模棱两可，我在这里姑且认为是会影响到程序的性能）。
堆和栈都是代码在运行时可供使用的内存，但是它们不尽相同：

### 栈
+ 栈以放入值的顺序存储值，并以相反的顺序取出值。这也被称为 **后进先出**。
+ 栈中所有的数据都必须占用已知且固定的大小。
+ 栈上访问数据会比堆更快。因为栈中的数据 “距离” 相对将近。
+ 栈中分配内存会更快，因为它无需为数据搜索新的内存空间，其存放位置总是在栈顶。
+ 指针存放在栈上，因为指针的大小是已知且固定的。


### 堆
+ 堆中可以存放未知的或大小可能变化的数据。
+ 堆存放数据时候，需要先请求一定大小的空间。内存分配器会在堆中的某处找到一块足够大的空位，并将其标记为使用，之后返回一个表示该地址位置的 **指针**。